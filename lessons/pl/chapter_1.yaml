- title: Rozdział 1 - Podstawy
  content_markdown: >
    W tym pierwszym rozdziale będziemy odkrywać podstawy dotyczące funkcji, zmiennych, oraz typów prymitywych.
    Cieszę się, że jesteś na pokładzie!


    W ogóle! W razie jakbyś się zastanawiał kim jest ten uroczy krab, który właśnie do ciebie mówi,
    nazywam się **Ferris**. Jestem nieoficjalną maskotką języka programowania Rust. Miło cię poznać.

- title: The Rust Playground
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Witaj!%20Mo%C5%BCesz%20modyfikowa%C4%87%20kod%20tutaj.%22)%3B%0A%7D%0A
  content_markdown: >
    Ten przewodnik korzysta z interaktywnego kompilatora online o nazwie
    [Rust Playground](https://play.rust-lang.org).


    To świetny sposób na zabawę z Rustem oraz pokazanie innym swojej kreatywności!
- title: Zmienne
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20rust%20infers%20the%20type%20of%20x%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20can%20also%20be%20explicit%20about%20the%20type%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20can%20also%20declare%20and%20initialize%20later%2C%20but%20this%20is%20rarely%20done%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
  content_markdown: >
    Zmienne są deklarowane z użyciem słowa kluczowego **let**.


    Podczas przypisywania wartości, Rust jest w stanie wydedukować typ twojej zmiennej w 99% przypadków.
    Jeśli jednak nie, możesz jawnie dodać typ zmiennej do deklaracji.


    Zauważ jak możemy przypisywać do tej samej nazwy zmiennej wiele razy.
    Jest to przysłanianie zmiennych. Typ może być inny dla każdej kolejnej zmiennej o tej samej nazwie.


    Nazwy zmiennych są zawsze zapisywane `snake_case`em.
- title: Modyfikowanie zmiennych
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
  content_markdown: >
    Rust zwraca szczególną uwagę na to, które zmienne można modyfikować.
    Wartości możemy podzielić na dwa typy:

    * **modyfikowalne** - kompilator zezwoli na odczyt i zapis do zmiennej.

    * **niemodyfikowalne** - kompilator zezwoli tylko na odczyt.


    Modyfikowalne wartości są oznaczane słowem kluczowym **mut**.


    Będziemy mieć więcej do powiedzenia na ten temat później, na razie tylko miej na oku
    to słowo kluczowe.
- title: Typy bazowe
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20domy%C5%9Blnie%20typu%20i32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20domy%C5%9Blnie%20typu%20f64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22witaj%20%C5%9Bwiecie!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A
  content_markdown: >
    Rust posiada wiele znajomych typów:

    * logiczne - `bool` reprezentują wartości prawda/fałsz

    * liczby całkowite bez znaku - `u8` `u16` `u32` `u64` `u128` reprezentują nieujemne liczby całkowite

    * liczby całkowite ze znakiem - `i8` `i16` `i32` `i64` `i128` reprezentują dodatnie/ujemne liczby całkowite

    * liczby całkowite o rozmiarach wskaźnika - `usize` `isize` reprezentują indeksy tablic i rozmiary obiektów
    w pamięci

    * zmiennoprzecinkowe - `f32` `f64`

    * krotki - `(wartość, wartość, ...)` dla przekazywania ciągów wartości określonej długości na stosie

    * tablice - `[wartość, wartość, ...]` kolekcja elementów tego samego typu o długości znanej w czasie kompilacji

    * wycinki *(ang. slice)* - kolekcja elementów tego samego typu o długości znanej w czasie wykonania

    * `str`(string slice) - tekst o długości znanej w czasie wykonania


    Łańcuchy znaków mogą być bardziej skomplikowane niż te, do których jesteś przyzwyczajony w innych językach;
    ponieważ Rust jest językiem programowania systemów, dba o problemy z pamięcią,
    do których możesz nie być przyzwyczajony. Zajmiemy się tym bardziej szczegółowo później.


    Typy numeryczne mogą być jawnie określone poprzez dodanie typu na koniec liczby (np. `13u32`, `2u8`).
- title: Konwersje typów podstawowych
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2013u8%3B%0A%20%20%20%20let%20b%20%3D%207u32%3B%0A%20%20%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20%20%20let%20t%20%3D%20true%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D%0A
  content_markdown: >
    Rust wymaga ścisłości jeśli chodzi o typy numeryczne.
    Nie można po prostu użyć `u8` zamiast `u32` bez błędu kompilacji.


    Na szczęście, Rust sprawia, że konwersje stają się bardzo proste przy użyciu słowa kluczowego **as**.
    Luckily Rust makes numeric type conversions very easy with the **as**
    keyword.
- title: Stałe
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22Aby%20uwa%C5%BCy%C4%87%20%7B%7Dwo%20od%20zera%2C%20najpierw%20nale%C5%BCy%20stworzy%C4%87%20wszech%C5%9Bwiat.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
  content_markdown: >
    Stałe pozwalają nam określić jedną wartość, która będzie wielokrotnie i efektywnie używana w naszym kodzie.
    Zamiast kopiować wartości tak jak zmienne w miejscu gdzie są użyte, stałe bezpośrednio zastępują identyfikator
    w czasie kompilacji.


    W odróżnieniu do zmiennych, stałe zawsze muszą mieć jawnie określony typ.


    Nazwy stałych są zawsze zapisywane `SCREAMING_SNAKE_CASE`em.
- title: Tablice
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20nums%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20nums)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20nums%5B1%5D)%3B%0A%7D%0A
  content_markdown: >
    *Tablica* to kolekcja elementów tego samego typu o stałej długości.


    Typ *tablcy* to `[T;N]`, gdzie T jest typem elementów, a N stałą długością znaną w czasie kompilacji.


    Dostęp do indywidualnych elementów może zostać uzyskany dzięki operatorowi `[x]`, gdzie *x* jest
    indeksem elementu typu *usize* (zaczynając od 0).
- title: Funkcje
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%20y%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20add(42%2C%2013))%3B%0A%7D%0A
  content_markdown: >
    Funkcja ma zero lub więcej parametrów.


    W tym przykładzie, add przyjmuje dwa argumenty typu `i32` (32 bitówych liczb całkowitych ze znakiem).


    Nazwy funkcji zapisujemy `snake_case`em.
- title: Wiele wartości zwracanych
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20zwr%C3%B3%C4%87%20krotk%C4%99%20warto%C5%9Bci%20zwracanych%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20rozbij%20krotk%C4%99%20na%20dwa%20indentyfikatory%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
  content_markdown: >
    Funkcję mogą zwracać wiele wartości poprzez **krotkę**.


    Do elementów kortki można odnosić się poprzez ich indeks.


    Rust obsługuje wiele rozdzajów rozbijania, które zobaczymy w wielu formach,
    pozwalając nam wyodrębniać podelementy struktur danych w ergonomiczny sposób.
    Bądź czujny!
- title: Zwracanie niczego
  content_markdown: >
    Jeśli typ zwracany nie jest określony, funkcja zwraca pustą krotkę, znaną także jako *unit*.


    Pusta krotka jest reprezentowana poprzez `()`.


    Używanie '()' nie jest powszechne, ale pojawia się na tyle często, że dobrze wiedzieć co się dzieje.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20make_nothing()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20typ%20zwracany%20to%20()%0Afn%20make_nothing2()%20%7B%0A%20%20%20%20%2F%2F%20funkcja%20zwr%C3%B3ci%20()%2C%20je%C5%9Bli%20warto%C5%9B%C4%87%20zwracana%20nie%20jest%20okre%C5%9Blona%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20make_nothing()%3B%0A%20%20%20%20let%20b%20%3D%20make_nothing2()%3B%0A%0A%20%20%20%20%2F%2F%20Wypisywanie%20debug%20stringa%20dla%20a%20i%20b%2C%0A%20%20%20%20%2F%2F%20poniewa%C5%BC%20ci%C4%99%C5%BCko%20wypisa%C4%87%20nico%C5%9B%C4%87%0A%20%20%20%20println!(%22The%20value%20of%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22The%20value%20of%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
- title: Rozdział 1 - Wnioski
  content_markdown: >
    Jak dotąd niezła robota! Podstawy Rusta nie są takie złe, prawda?

    Zaczynamy zagłębiać się w to jak kompilator Rusta myśli.

    Jako język programowania systemowego Rust bardzo dba o rozmiar zmiennych w pamięci,
    o to czy obiekty można modyfikować, czy nie, upewnia się, czy twoja matematyka jest taka, jak chcesz.

    Następnie przyjrzymy się starym znajomym:
    instrukcjom warunkowym `if` oraz pętlom `for`.


    Zobacz więcej:


    * [Youtube: Rust Cast - A deeper dive on Rust's primitive number
    types](https://www.youtube.com/watch?v=n5TRBkbystY)

    * [Website: Rust Book 2018 - A deeper description on basic data
    types](https://doc.rust-lang.org/1.30.0/book/2018-edition/ch03-02-data-types.html)

    * [Website: Rust Cheat Sheet - Data Types](https://cheats.rs/#basic-types)
