- title: Rozdział 1 - Podstawy
  content_markdown: >
    W tym pierwszym rozdziale będziemy odkrywać podstawy dotyczące funkcji, zmiennych, oraz typów prymitywych.
    Cieszę się, że jesteś na pokładzie!


    W ogóle! W razie jakbyś się zastanawiał kim jest ten uroczy krab, który właśnie do ciebie mówi,
    nazywam się **Ferris**. Jestem nieoficjalną maskotką języka programowania Rust. Miło cię poznać.

- title: The Rust Playground
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Witaj!%20Mo%C5%BCesz%20modyfikowa%C4%87%20kod%20tutaj.%22)%3B%0A%7D%0A
  content_markdown: >
    Ten przewodnik korzysta z interaktywnego kompilatora online o nazwie
    [Rust Playground](https://play.rust-lang.org).


    To świetny sposób na zabawę z Rustem oraz pokazanie innym swojej kreatywności!
- title: Zmienne
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20rust%20infers%20the%20type%20of%20x%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20can%20also%20be%20explicit%20about%20the%20type%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20can%20also%20declare%20and%20initialize%20later%2C%20but%20this%20is%20rarely%20done%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
  content_markdown: >
    Zmienne są deklarowane z użyciem słowa kluczowego **let**.


    Podczas przypisywania wartości, Rust jest w stanie wydedukować typ twojej zmiennej w 99% przypadków.
    Jeśli jednak nie, możesz jawnie dodać typ zmiennej do deklaracji.


    Zauważ jak możemy przypisywać do tej samej nazwy zmiennej wiele razy.
    Jest to przysłanianie zmiennych. Typ może być inny dla każdej kolejnej zmiennej o tej samej nazwie.


    Nazwy zmiennych są zawsze zapisywane `snake_case`em.
- title: Modyfikowanie zmiennych
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
  content_markdown: >
    Rust cares a great deal about what variables are modifiable. Values
    Rust zwraca szczególną uwagę na to, które zmienne można modyfikować.
    Wartości możemy podzieli na dwa typy:

    * **modyfikowalne** - kompilator zezwoli na odczyt i zapis do zmiennej.

    * **niemodyfikowalne** - kompilator zezwoli tylko na odczyt.


    Modyfikowalne wartości są oznaczane słowem kluczowym **mut**.


    Będziemy mieć więcej do powiedzenia na ten temat później, na razie tylko miej na oku
    to słowo kluczowe.
- title: Typy bazowe
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20domy%C5%9Blnie%20typu%20i32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20domy%C5%9Blnie%20typu%20f64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22witaj%20%C5%9Bwiecie!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A
  content_markdown: >
    Rust posiada wiele znajomych typów:

    * logiczne - `bool` reprezentują wartości prawda/fałsz

    * liczby całkowite bez znaku - `u8` `u16` `u32` `u64` `u128` reprezentują nieujemne liczby całkowite

    * liczby całkowite ze znakiem - `i8` `i16` `i32` `i64` `i128` reprezentują dodatnie/ujemne liczby całkowite

    * liczby całkowite o rozmiarach wskaźnika - `usize` `isize` reprezentują indeksy tablic i rozmiary obiektów
    w pamięci

    * zmiennoprzecinkowe - `f32` `f64`

    * krotki - `(wartość, wartość, ...)` dla przekazywania ciągów wartości określonej długości na stosie

    * tablice - `[wartość, wartość, ...]` kolekcja elementów tego samego typu o długości znanej w czasie kompilacji

    * wycinki *(ang. slice)* - kolekcja elementów tego samego typu o długości znanej w czasie wykonania

    * `str`(string slice) - tekst o długości znanej w czasie wykonania


    Łańcuchy znaków mogą być bardziej skomplikowane niż te, do których jesteś przyzwyczajony w innych językach;
    ponieważ Rust jest językiem programowania systemów, dba o problemy z pamięcią,
    do których możesz nie być przyzwyczajony. Zajmiemy się tym bardziej szczegółowo później.


    Typy numeryczne mogą być jawnie określone poprzez dodanie typu na koniec liczby (np. `13u32`, `2u8`).
- title: Konwersje typów podstawowych
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2013u8%3B%0A%20%20%20%20let%20b%20%3D%207u32%3B%0A%20%20%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20%20%20let%20t%20%3D%20true%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D%0A
  content_markdown: >
    Rust wymaga ścisłości jeśli chodzi o typy numeryczne.
    Nie można po prostu użyć `u8` zamiast `u32` bez błędu kompilacji.


    Na szczęście, Rust sprawia, że konwersje stają się bardzo proste przy użyciu słowa kluczowego **as**.
    Luckily Rust makes numeric type conversions very easy with the **as**
    keyword.
- title: Stałe
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22Aby%20uwa%C5%BCy%C4%87%20%7B%7Dwo%20od%20zera%2C%20najpierw%20nale%C5%BCy%20stworzy%C4%87%20wszech%C5%9Bwiat.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
  content_markdown: >
    Stałe pozwalają nam określić jedną wartość, która będzie wielokrotnie i efektywnie używana w naszym kodzie.
    Zamiast kopiować wartości tak jak zmienne w miejscu gdzie są użyte, stałe bezpośrednio zastępują identyfikator
    w czasie kompilacji.


    W odróżnieniu do zmiennych, stałe zawsze muszą mieć jawnie określony typ.


    Nazwy stałych są zawsze zapisywane `SCREAMING_SNAKE_CASE`em.
- title: Arrays
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20nums%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20nums)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20nums%5B1%5D)%3B%0A%7D%0A
  content_markdown: >
    An *array* is a fixed length collection of data elements all of the same
    type.


    The data type for an *array* is `[T;N]` where T is the elements' type, and N
    is the fixed length known at compile-time.


    Individual elements can be retrieved with the `[x]` operator where *x* is a
    *usize* index (starting at 0) of the element you want.
- title: Functions
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%20y%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20add(42%2C%2013))%3B%0A%7D%0A
  content_markdown: >
    A function has zero or more parameters.


    In this example, add takes two arguments of type `i32` (signed integer of
    32-bit

    length).


    Function names are always in `snake_case`.
- title: Multiple Return Values
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20return%20a%20tuple%20of%20return%20values%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20destructure%20the%20tuple%20into%20two%20variables%20names%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
  content_markdown: >
    Functions can return multiple values by returning a **tuple**

    of values.


    Tuple elements can be referenced by their index number.


    Rust supports various kinds of destructuring that we will see in many forms,
    allowing

    us to extract sub-pieces of data structures in ergonomic ways. Be on the
    lookout!
- title: Returning Nothing
  content_markdown: >
    If no return type is specified for a function, it returns an empty tuple,
    also known as a *unit*.


    An empty tuple is represented by `()`.


    Using `()` is uncommon, but will come up often enough that it's good to know
    whats happening.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20make_nothing()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20the%20return%20type%20is%20implied%20as%20()%0Afn%20make_nothing2()%20%7B%0A%20%20%20%20%2F%2F%20this%20function%20will%20return%20()%20if%20nothing%20is%20specified%20to%20return%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20make_nothing()%3B%0A%20%20%20%20let%20b%20%3D%20make_nothing2()%3B%0A%0A%20%20%20%20%2F%2F%20Printing%20a%20debug%20string%20for%20a%20and%20b%0A%20%20%20%20%2F%2F%20Because%20it's%20hard%20to%20print%20nothingness%0A%20%20%20%20println!(%22The%20value%20of%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22The%20value%20of%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
- title: Chapter 1 - Conclusion
  content_markdown: >
    Nice job so far! The basics of Rust aren't so bad, right?  We're

    getting a peek into how the Rust compiler thinks.  As a system programming
    language 

    it cares a lot about the size  of values in memory, whether things can be
    modified or not, 

    and making sure your math is what you want it to be. Next up we'll be
    looking at some old friends:

    `if` tests and `for` loops.


    More Resources:


    * [Youtube: Rust Cast - A deeper dive on Rust's primitive number
    types](https://www.youtube.com/watch?v=n5TRBkbystY)

    * [Website: Rust Book 2018 - A deeper description on basic data
    types](https://doc.rust-lang.org/1.30.0/book/2018-edition/ch03-02-data-types.html)

    * [Website: Rust Cheat Sheet - Data Types](https://cheats.rs/#basic-types)
